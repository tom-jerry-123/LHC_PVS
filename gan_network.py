"""
Class for generative adversarial network
Currently uses a GAN autoencoder
"""


import tensorflow as tf
import numpy as np
import keras


class GanAutoencoder:
    """
    Autoencoder with Discriminator. Code generated by ChatGPT
    """
    def __init__(self, input_dim, latent_dim):
        # Build autoencoder
        self._encoder = self._build_encoder(input_dim, latent_dim)
        self._decoder = self._build_decoder(latent_dim, output_dim=input_dim)
        autoencoder_output = self._decoder(self._encoder.output[0])
        self._autoencoder = tf.keras.models.Model(self._encoder.input, autoencoder_output, name="autoencoder")

        # Build and compile discriminator
        self._discriminator = self._build_discriminator(input_dim)
        self._discriminator.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=1e-4),
                              loss='binary_crossentropy',
                              metrics=['accuracy'])

        # Compile combined model
        self._discriminator.trainable = False
        reconstructed = self._autoencoder(self._encoder.input)
        validity = self._discriminator(reconstructed)
        self._combined_model = tf.keras.models.Model(self._encoder.input, [reconstructed, validity])
        self._combined_model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=1e-4),
                               loss=['mse', 'binary_crossentropy'],
                               loss_weights=[0.5, 0.5])  # Adjust loss weights as necessary

        print(self._autoencoder.summary())

    @staticmethod
    def _build_encoder(input_dim, latent_dim):
        """
        Only use this to build the encoder network of autoencoder
        :return: tf.keras.Model
        """
        inputs = tf.keras.Input(shape=(input_dim,))
        x = tf.keras.layers.Flatten()(inputs)
        x = tf.keras.layers.Dense(32, activation='relu')(x)
        latent = tf.keras.layers.Dense(latent_dim, activation='relu')(x)
        return tf.keras.models.Model(inputs, latent, name='encoder')

    @staticmethod
    def _build_decoder(latent_dim, output_dim):
        inputs = tf.keras.Input(shape=(latent_dim,))
        x = tf.keras.layers.Dense(32, activation='relu')(inputs)
        outputs = keras.layers.Dense(input_shape=(output_dim,), activation='relu')(x)
        return tf.keras.models.Model(inputs, outputs, name='decoder')

    @staticmethod
    def _build_discriminator(input_dim):
        inputs = tf.keras.Input(shape=(input_dim,))
        x = tf.keras.layers.Dense(32, activation='relu')(inputs)
        x = tf.keras.layers.Dense(1, activation='sigmoid')(x)
        return tf.keras.models.Model(inputs, x, name='discriminator')

    def train(self, X_train, epochs, batch_size=256, verbose=False):
        """
        Training loop for adversarial network
        :param X_train:
        :param epochs:
        :param batch_size:
        :param verbose:
        :return:
        """
        if batch_size < 16:
            batch_size = 16
            raise RuntimeWarning("Batch size < 16 not supported (batch size set to 16).")
        N_data_points = X_train.shape[0]

        for epoch in range(epochs):
            batch_idx_arrs = self._batch_partition(N_data_points, batch_size)

            for idxs in batch_idx_arrs:
                # 1. Train the discriminator. First set trainable to be true
                self._discriminator.trainable = True
                # Prepare samples
                real_samples = X_train[idxs]
                reconstructed_samples = self._autoencoder.predict(real_samples)
                all_samples = np.concatenate((real_samples, reconstructed_samples), axis=0)
                real = np.ones(idxs.shape[0])
                fake = np.zeros(idxs.shape[0])
                sample_labels = np.concatenate((real, fake))
                # Train, record loss
                d_loss = self._discriminator.train_on_batch(all_samples, sample_labels)
                # Remember to set the discriminator to be untrainable once we're done training it on this batch
                self._discriminator.trainable = False

                # 2. Train the combined model (autoencoder + adversarial)
                g_loss = self._combined_model.train_on_batch(real_samples, [real_samples, real])

            # Print the progress
            print(f"{epoch} [D loss: {d_loss[0]}, acc.: {100 * d_loss[1]}%] [G loss: {g_loss}]")

    def _batch_partition(self, num_data, batch_size):
        idxs = np.arange(num_data)
        idxs = np.random.permutation(idxs)
        batch_idx_arrs = np.array_split(idxs, np.arange(batch_size, num_data, batch_size))
        if len(batch_idx_arrs[-1]) < 0.75 * batch_size:
            # cut last batch if it is too small to avoid training instability
            batch_idx_arrs = batch_idx_arrs[:-1]
        return batch_idx_arrs


class GanNetwork:
    """
    ChatGPT did not give working model. New attempt following examples on Keras and TF
    """
    def __init__(self, generator, discriminator):
        self._generator = generator
        self._discriminator = discriminator

    @staticmethod
    def build_autoencoder(self, input_dim, latent_dim):
        autoencoder = keras.Sequential(
            [
                keras.layers.InputLayer((input_dim,)),
                keras.layers.Dense(32, activation="relu"),
                keras.layers.Dense(latent_dim, activation="relu"),
                keras.layers.Dense(32, activation="relu"),
                keras.layers.Dense(input_dim, activation="relu"),
            ],
            name="autoencoder",
        )
        return autoencoder

    @staticmethod
    def build_discriminator(self, input_dim):
        discriminator = keras.Sequential(
            [
                keras.layers.InputLayer((input_dim,)),
                keras.layers.Dense(32, activation="relu"),
                keras.layers.Dense(1, activation="sigmoid"),
            ],
            name="discriminator",
        )
        return discriminator
